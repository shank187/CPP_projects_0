# include "Fixed.hpp"
#include <iostream>

Fixed::Fixed() : value(0){
    std::cout << "Default constructor called" << std::endl;
}

Fixed::Fixed(const Fixed& other)
{
    this->value = other.value;
    std::cout << "Copy constructor called" <<  std::endl;
}

Fixed& Fixed::operator=(const Fixed& other)
{
    std::cout << "Copy assignment operator called" << std::endl;
    if (this != &other)
        this->value = other.value;
    return *this;
}

Fixed::~Fixed()
{
    std::cout << "Destructor called" << std::endl;
}

int Fixed::getRawBits() const
{
    std::cout << "getRawBits member function called" << std::endl;
    return this->value;
}
void Fixed::setRawBits(int const raw)
{
    std::cout << "setRawBits member function called" << std::endl;
    this->value = raw;
}
#ifndef FIXED_HPP
#define FIXED_HPP

class Fixed {
private:
    int                 value;
    static const int    fractionalBits = 8;
public:
    Fixed();
    Fixed(const Fixed& other);
    Fixed& operator=(const Fixed& other);
    ~Fixed();
    int getRawBits() const;
    void setRawBits(int const raw);
};


#endifNAME = fixed

CXX = c++
CXXFLAGS = -Wall -Wextra -Werror -std=c++98

SRC = main.cpp Fixed.cpp
OBJ = $(SRC:.cpp=.o)

HEADERS = Fixed.hpp

all: $(NAME)

$(NAME): $(OBJ)
		$(CXX) $(CXXFLAGS) $(OBJ) -o $(NAME)

%.o: %.cpp $(HEADERS)
		$(CXX) $(CXXFLAGS) -c $< -o $@

clean:
		rm -f $(OBJ)

fclean: clean
		rm -f $(NAME)

re: fclean all

.PHONY: all clean fclean re#include <iostream>
#include "Fixed.hpp"

int main( void ) {
    Fixed a;
    Fixed b( a );
    Fixed c;
    c = b;
    std::cout << a.getRawBits() << std::endl;
    std::cout << b.getRawBits() << std::endl;
    std::cout << c.getRawBits() << std::endl;
    return 0;
}
# include "Fixed.hpp"
#include <iostream>

Fixed::Fixed() : value(0){
    std::cout << "Default constructor called" << std::endl;
}

Fixed::Fixed(const Fixed& other)
{
    this->value = other.value;
    std::cout << "Copy constructor called" <<  std::endl;
}

Fixed& Fixed::operator=(const Fixed& other)
{
    std::cout << "Copy assignment operator called" << std::endl;
    if (this != &other)
        this->value = other.value;
    return *this;
}

Fixed::Fixed(const int value)
{
    std::cout << "Int constructor called" << std::endl;
    this->value = value << fractionalBits;
}

Fixed::Fixed(const float value)
{
    std::cout << "Float constructor called" << std::endl;
    this->value = static_cast<int>(roundf(value * (1 << fractionalBits)));
}

Fixed::~Fixed()
{
    std::cout << "Destructor called" << std::endl;
}
int Fixed::getRawBits() const
{
    std::cout << "getRawBits member function called" << std::endl;
    return this->value;
}
void Fixed::setRawBits(int const raw)
{
    std::cout << "setRawBits member function called" << std::endl;
    this->value = raw;
}

float Fixed::toFloat(void) const
{
    return static_cast<float>(this->value) / (1 << fractionalBits);
}
int Fixed::toInt(void) const
{
    return this->value >> fractionalBits;
}

std::ostream& operator<<(std::ostream& os, const Fixed& fixed)
{
    os << fixed.toFloat();
    return os;
}#ifndef FIXED_HPP
#define FIXED_HPP

#include <cmath>
#include <iostream>

class Fixed {
private:
    int                 value;
    static const int    fractionalBits = 8;
public:
    Fixed(const int value);
    Fixed(const float value);
    Fixed(const Fixed& other);
    Fixed();
    Fixed& operator=(const Fixed& other);
    ~Fixed();
    int getRawBits() const;
    void setRawBits(int const raw);
    float toFloat(void) const;
    int toInt(void) const;

};

std::ostream& operator<<(std::ostream& out, const Fixed& f);


#endifNAME = fixed

CXX = c++
CXXFLAGS = -Wall -Wextra -Werror -std=c++98

SRC = main.cpp Fixed.cpp
OBJ = $(SRC:.cpp=.o)

HEADERS = Fixed.hpp

all: $(NAME)

$(NAME): $(OBJ)
		$(CXX) $(CXXFLAGS) $(OBJ) -o $(NAME)

%.o: %.cpp $(HEADERS)
		$(CXX) $(CXXFLAGS) -c $< -o $@

clean:
		rm -f $(OBJ)

fclean: clean
		rm -f $(NAME)

re: fclean all#include "Fixed.hpp"
#include <iostream>

int main( void )
{
    Fixed a;
    Fixed const b( 10 );
    Fixed const c( 42.42f );
    Fixed const d( b );
    a = Fixed( 1234.4321f );
    
    std::cout << "a is " << a << std::endl;
    std::cout << "b is " << b << std::endl;
    std::cout << "c is " << c << std::endl;
    std::cout << "d is " << d << std::endl;
    std::cout << "a is " << a.toInt() << " as integer" << std::endl;
    std::cout << "b is " << b.toInt() << " as integer" << std::endl;
    std::cout << "c is " << c.toInt() << " as integer" << std::endl;
    std::cout << "d is " << d.toInt() << " as integer" << std::endl;
    
    return 0;
}
# include "Fixed.hpp"
#include <iostream>

Fixed::Fixed() : value(0){
    std::cout << "Default constructor called" << std::endl;
}

Fixed::Fixed(const Fixed& other)
{
    this->value = other.value;
    std::cout << "Copy constructor called" <<  std::endl;
}

Fixed::Fixed(const int value)
{
    std::cout << "Int constructor called" << std::endl;
    this->value = value << fractionalBits;
}

Fixed::Fixed(const float value)
{
    std::cout << "Float constructor called" << std::endl;
    this->value = static_cast<int>(roundf(value * (1 << fractionalBits)));
}

Fixed::~Fixed()
{
    std::cout << "Destructor called" << std::endl;
}
int Fixed::getRawBits() const
{
    std::cout << "getRawBits member function called" << std::endl;
    return this->value;
}
void Fixed::setRawBits(int const raw)
{
    std::cout << "setRawBits member function called" << std::endl;
    this->value = raw;
}

float Fixed::toFloat(void) const
{
    return static_cast<float>(this->value) / (1 << fractionalBits);
}
int Fixed::toInt(void) const
{
    return this->value >> fractionalBits;
}

std::ostream& operator<<(std::ostream& os, const Fixed& fixed)
{
    os << fixed.toFloat();
    return os;
}

Fixed& Fixed::operator=(const Fixed& other)
{
    std::cout << "Copy assignment operator called" << std::endl;
    if (this != &other)
        this->value = other.value;
    return *this;
}
Fixed Fixed::operator+(const Fixed& other) const
{
    Fixed result;
    result.value = this->value + other.value;
    return result;
}
Fixed Fixed::operator-(const Fixed& other) const
{
    Fixed result;
    result.value = this->value - other.value;
    return result;
}

Fixed Fixed::operator*(const Fixed& other) const
{
    long temp = static_cast<long>(this->value) * static_cast<long>(other.value);
    Fixed result;
    result.value = static_cast<int>(temp >> fractionalBits);
    return result;
}


Fixed Fixed::operator/(const Fixed& other) const
{
    Fixed result;

    if (other.value == 0)
    {
        std::cerr << "Error: division by zero" << std::endl;
        return Fixed();
    }
    long temp = (static_cast<long>(this->value) << fractionalBits) / static_cast<long>(other.value);
    result.value = static_cast<int>(temp);
    return result;
}

Fixed& Fixed::operator++()        // Prefix increment
{
    this->value++;
    return *this;
}

Fixed Fixed::operator++(int)    // Postfix increment
{
    Fixed temp = *this;
    this->value++;
    return temp;
}

Fixed& Fixed::operator--()       // Prefix decrement
{
    this->value--;
    return *this;
}

Fixed Fixed::operator--(int)    // Postfix decrement
{
    Fixed temp = *this;
    this->value--;
    return temp;
}

bool Fixed::operator>(const Fixed& other) const
{
    return this->value > other.value;
}

bool Fixed::operator<(const Fixed& other) const
{
    return this->value < other.value;
}

bool Fixed::operator>=(const Fixed& other) const
{
    return this->value >= other.value;
}

bool Fixed::operator<=(const Fixed& other) const
{
    return this->value <= other.value;
}
bool Fixed::operator==(const Fixed& other) const
{
    return this->value == other.value;
}
bool Fixed::operator!=(const Fixed& other) const
{
    return this->value != other.value;
}
Fixed& Fixed::min(Fixed& a, Fixed& b)
{
    return (a < b) ? a : b;
}
const Fixed& Fixed::min(const Fixed& a, const Fixed& b)
{
    return (a < b) ? a : b;
}
Fixed& Fixed::max(Fixed& a, Fixed& b)
{
    return (a > b) ? a : b;
}
const Fixed& Fixed::max(const Fixed& a, const Fixed& b)
{
    return (a > b) ? a : b;
}

#ifndef FIXED_HPP
#define FIXED_HPP

#include <cmath>
#include <iostream>
#include <climits>

class Fixed {
private:
    int                 value;
    static const int    fractionalBits = 8;
public:
    Fixed(const int value);
    Fixed(const float value);
    Fixed(const Fixed& other);
    Fixed();
    ~Fixed();

    Fixed& operator=(const Fixed& other);
    Fixed operator+(const Fixed& other) const;
    Fixed operator-(const Fixed& other) const;
    Fixed operator*(const Fixed& other) const;
    Fixed operator/(const Fixed& other) const;
    Fixed& operator++();        // Prefix increment
    Fixed operator++(int);     // Postfix increment
    Fixed& operator--();       // Prefix decrement
    Fixed operator--(int);    // Postfix decrement
    bool operator>(const Fixed& other) const;
    bool operator<(const Fixed& other) const;
    bool operator>=(const Fixed& other) const;
    bool operator<=(const Fixed& other) const;
    bool operator==(const Fixed& other) const;
    bool operator!=(const Fixed& other) const;

    int getRawBits() const;
    void setRawBits(int const raw);
    static Fixed& min(Fixed& a, Fixed& b);
    static const  Fixed& min(const Fixed& a, const Fixed& b);
    static Fixed& max(Fixed& a, Fixed& b);
    static const Fixed& max(const Fixed& a, const Fixed& b);
    float toFloat(void) const;
    int toInt(void) const;

};

std::ostream& operator<<(std::ostream& out, const Fixed& f);


#endifNAME = fixed

CXX = c++
CXXFLAGS = -Wall -Wextra -Werror -std=c++98

SRC = main.cpp Fixed.cpp
OBJ = $(SRC:.cpp=.o)

HEADERS = Fixed.hpp

all: $(NAME)

$(NAME): $(OBJ)
		$(CXX) $(CXXFLAGS) $(OBJ) -o $(NAME)

%.o: %.cpp $(HEADERS)
		$(CXX) $(CXXFLAGS) -c $< -o $@

clean:
		rm -f $(OBJ)

fclean: clean
		rm -f $(NAME)

re: fclean all#include <iostream>
#include "Fixed.hpp"

int main( void ) {
Fixed a;
Fixed const b( Fixed( 5.05f ) * Fixed( 2 ) );
std::cout << a << std::endl;
std::cout << ++a << std::endl;
std::cout << a << std::endl;
std::cout << a++ << std::endl;
std::cout << a << std::endl;
std::cout << b << std::endl;
std::cout << Fixed::max( a, b ) << std::endl;
return 0;
}# include "Fixed.hpp"
#include <iostream>

Fixed::Fixed() : value(0){
    // std::cout << "Default constructor called" << std::endl;
}

Fixed::Fixed(const Fixed& other)
{
    this->value = other.value;
    // std::cout << "Copy constructor called" <<  std::endl;
}

Fixed::Fixed(const int value)
{
    // std::cout << "Int constructor called" << std::endl;
    this->value = value << fractionalBits;
}

Fixed::Fixed(const float value)
{
    // std::cout << "Float constructor called" << std::endl;
    this->value = static_cast<int>(roundf(value * (1 << fractionalBits)));
}

Fixed::~Fixed()
{
    // std::cout << "Destructor called" << std::endl;
}
int Fixed::getRawBits() const
{
    // std::cout << "getRawBits member function called" << std::endl;
    return this->value;
}
void Fixed::setRawBits(int const raw)
{
    // std::cout << "setRawBits member function called" << std::endl;
    this->value = raw;
}

float Fixed::toFloat(void) const
{
    return static_cast<float>(this->value) / (1 << fractionalBits);
}
int Fixed::toInt(void) const
{
    return this->value >> fractionalBits;
}

std::ostream& operator<<(std::ostream& os, const Fixed& fixed)
{
    os << fixed.toFloat();
    return os;
}

Fixed& Fixed::operator=(const Fixed& other)
{
    // std::cout << "Copy assignment operator called" << std::endl;
    if (this != &other)
        this->value = other.value;
    return *this;
}
Fixed Fixed::operator+(const Fixed& other) const
{
    Fixed result;
    result.value = this->value + other.value;
    return result;
}
Fixed Fixed::operator-(const Fixed& other) const
{
    Fixed result;
    result.value = this->value - other.value;
    return result;
}

Fixed Fixed::operator*(const Fixed& other) const
{
    long temp = static_cast<long>(this->value) * static_cast<long>(other.value);
    Fixed result;
    result.value = static_cast<int>(temp >> fractionalBits);
    return result;
}


Fixed Fixed::operator/(const Fixed& other) const
{
    Fixed result;

    if (other.value == 0)
    {
        std::cerr << "Error: division by zero" << std::endl;
        return Fixed();
    }
    long temp = (static_cast<long>(this->value) << fractionalBits) / static_cast<long>(other.value);
    result.value = static_cast<int>(temp);
    return result;
}

Fixed& Fixed::operator++()        // Prefix increment
{
    this->value++;
    return *this;
}

Fixed Fixed::operator++(int)    // Postfix increment
{
    Fixed temp = *this;
    this->value++;
    return temp;
}

Fixed& Fixed::operator--()       // Prefix decrement
{
    this->value--;
    return *this;
}

Fixed Fixed::operator--(int)    // Postfix decrement
{
    Fixed temp = *this;
    this->value--;
    return temp;
}

bool Fixed::operator>(const Fixed& other) const
{
    return this->value > other.value;
}

bool Fixed::operator<(const Fixed& other) const
{
    return this->value < other.value;
}

bool Fixed::operator>=(const Fixed& other) const
{
    return this->value >= other.value;
}

bool Fixed::operator<=(const Fixed& other) const
{
    return this->value <= other.value;
}
bool Fixed::operator==(const Fixed& other) const
{
    return this->value == other.value;
}
bool Fixed::operator!=(const Fixed& other) const
{
    return this->value != other.value;
}
Fixed& Fixed::min(Fixed& a, Fixed& b)
{
    return (a < b) ? a : b;
}
const Fixed& Fixed::min(const Fixed& a, const Fixed& b)
{
    return (a < b) ? a : b;
}
Fixed& Fixed::max(Fixed& a, Fixed& b)
{
    return (a > b) ? a : b;
}
const Fixed& Fixed::max(const Fixed& a, const Fixed& b)
{
    return (a > b) ? a : b;
}

#ifndef FIXED_HPP
#define FIXED_HPP

#include <cmath>
#include <iostream>
#include <climits>

class Fixed {
private:
    int                 value;
    static const int    fractionalBits = 8;
public:
    Fixed(const int value);
    Fixed(const float value);
    Fixed(const Fixed& other);
    Fixed();
    ~Fixed();

    Fixed& operator=(const Fixed& other);
    Fixed operator+(const Fixed& other) const;
    Fixed operator-(const Fixed& other) const;
    Fixed operator*(const Fixed& other) const;
    Fixed operator/(const Fixed& other) const;
    Fixed& operator++();        // Prefix increment
    Fixed operator++(int);     // Postfix increment
    Fixed& operator--();       // Prefix decrement
    Fixed operator--(int);    // Postfix decrement
    bool operator>(const Fixed& other) const;
    bool operator<(const Fixed& other) const;
    bool operator>=(const Fixed& other) const;
    bool operator<=(const Fixed& other) const;
    bool operator==(const Fixed& other) const;
    bool operator!=(const Fixed& other) const;

    int getRawBits() const;
    void setRawBits(int const raw);
    static Fixed& min(Fixed& a, Fixed& b);
    static const  Fixed& min(const Fixed& a, const Fixed& b);
    static Fixed& max(Fixed& a, Fixed& b);
    static const Fixed& max(const Fixed& a, const Fixed& b);
    float toFloat(void) const;
    int toInt(void) const;

};

std::ostream& operator<<(std::ostream& out, const Fixed& f);


#endifNAME = fixed

CXX = c++
CXXFLAGS = -Wall -Wextra -Werror -std=c++98

SRC = main.cpp Fixed.cpp Point.cpp bsp.cpp
OBJ = $(SRC:.cpp=.o)

HEADERS = Fixed.hpp Point.hpp

all: $(NAME)

$(NAME): $(OBJ)
		$(CXX) $(CXXFLAGS) $(OBJ) -o $(NAME)

%.o: %.cpp $(HEADERS)
		$(CXX) $(CXXFLAGS) -c $< -o $@

clean:
		rm -f $(OBJ)

fclean: clean
		rm -f $(NAME)

re: fclean all#include "Point.hpp"
#include "Fixed.hpp"


Point::Point() : x(0), y(0) {}
Point::Point(Fixed x, Fixed y) : x(x), y(y) {}
Point::Point(const Point& other) : x(other.x), y(other.y) {}
Point::~Point() {}

Point& Point::operator=(const Point& other) {
    if (this != &other) {
        // Since x and y are const, we cannot assign to them.
        // This operator= is effectively useless in this case.
    }
    return *this;
}

Fixed Point::getX() const {
    return x;
}
Fixed Point::getY() const {
    return y;
}
#ifndef POINT_HPP
#define POINT_HPP
#include "Fixed.hpp"

class Point {
public:
    Point();
    Point(Fixed x, Fixed y);
    Point(const Point& other);
    ~Point();

    Point& operator=(const Point& other);

    Fixed getX() const;
    Fixed getY() const;

private:
    const Fixed x;
    const Fixed y;
};

bool bsp( Point const a, Point const b, Point const c, Point const point);

#endif // POINT_HPP#include "Fixed.hpp"
#include "Point.hpp"


Fixed get_triangle_area(Point p1, Point p2, Point p3)
{
    Point vector1(p1.getX() - p2.getX(), p1.getY() - p2.getY());
    Point vector2(p1.getX() - p3.getX(), p1.getY() - p3.getY());

    Fixed cross_product = vector1.getX() * vector2.getY() - vector1.getY()* vector2.getX();
    if (cross_product < Fixed(0))
        cross_product = cross_product * Fixed(-1);
    return cross_product / Fixed(2);
}

bool bsp( Point const a, Point const b, Point const c, Point const point)
{
    Fixed triangle_area = get_triangle_area(a, b, c);
    Fixed sub_tri_1_area = get_triangle_area(point, a, b);
    Fixed sub_tri_2_area = get_triangle_area(point, b, c);
    Fixed sub_tri_3_area = get_triangle_area(point, c, a);

    return (
        (sub_tri_1_area > Fixed(0)) &&
        (sub_tri_2_area > Fixed(0)) &&
        (sub_tri_3_area > Fixed(0)) &&
        (triangle_area == sub_tri_1_area + sub_tri_2_area + sub_tri_3_area)
    );
}#include <iostream>
#include "Fixed.hpp"
#include "Point.hpp"

#include <iostream>
#include "Point.hpp"

// Forward declaration (if not in a header)
bool bsp(Point const a, Point const b, Point const c, Point const point);

void test_case(const Point& a, const Point& b, const Point& c, const Point& p, const std::string& label)
{
    std::cout << "=== " << label << " ===" << std::endl;
    std::cout << "Triangle: A(" << a.getX() << ", " << a.getY()
              << "), B(" << b.getX() << ", " << b.getY()
              << "), C(" << c.getX() << ", " << c.getY() << ")\n";
    std::cout << "Point: P(" << p.getX() << ", " << p.getY() << ")\n";

    bool inside = bsp(a, b, c, p);
    std::cout << "Result: P is " 
              << (inside ? "INSIDE ✅" : "OUTSIDE ❌") 
              << " the triangle\n\n";
}

int main()
{
    Point a(0, 0);
    Point b(10, 0);
    Point c(5, 10);

    // ✅ Inside
    Point p1(5, 3);
    test_case(a, b, c, p1, "Case 1: Inside");

    // ❌ Outside (below the base)
    Point p2(5, -1);
    test_case(a, b, c, p2, "Case 2: Below");

    // ❌ Outside (to the right)
    Point p3(11, 3);
    test_case(a, b, c, p3, "Case 3: Outside right");

    // ⚠️ On the edge AB
    Point p4(5, 0);
    test_case(a, b, c, p4, "Case 4: On edge AB");

    // ⚠️ On the vertex A
    Point p5(0, 0);
    test_case(a, b, c, p5, "Case 5: On vertex A");

    // ✅ Inside near center
    Point p6(5, 4.9f);
    test_case(a, b, c, p6, "Case 6: Deep inside");

    // ❌ Clearly outside far away
    Point p7(20, 20);
    test_case(a, b, c, p7, "Case 7: Far outside");

    // ✅ Another inside near edge
    Point p8(4, 2);
    test_case(a, b, c, p8, "Case 8: Inside near edge");

    // ✅ Small triangle test
    Point a2(0, 0), b2(2, 0), c2(1, 2);
    Point p9(1, 0.5f);
    test_case(a2, b2, c2, p9, "Case 9: Small triangle inside");

    // ❌ Small triangle outside
    Point p10(3, 3);
    test_case(a2, b2, c2, p10, "Case 10: Small triangle outside");

    return 0;
}
ex00/Fixed.cpp
ex00/Fixed.hpp
ex00/Makefile
ex00/main.cpp
ex01/Fixed.cpp
ex01/Fixed.hpp
ex01/Makefile
ex01/main.cpp
ex02/Fixed.cpp
ex02/Fixed.hpp
ex02/Makefile
ex02/main.cpp
ex03/Fixed.cpp
ex03/Fixed.hpp
ex03/Makefile
ex03/Point.cpp
ex03/Point.hpp
ex03/bsp.cpp
ex03/main.cpp
